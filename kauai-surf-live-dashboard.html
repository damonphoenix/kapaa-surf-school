<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kaua ªi Surf Dashboard ‚Ä¢ Live Wave Conditions ‚Ä¢ 8 Major Breaks</title>
  <meta name="description" content="The most complete, accurate real-time surf dashboard for Kaua ªi. V1 surf rating ‚Ä¢ 8 breaks ‚Ä¢ NOAA NWS + tides ‚Ä¢ Face + Hawaiian heights ‚Ä¢ Swell compass ‚Ä¢ Per-spot scoring." />
  <link rel="stylesheet" href="assets/css/tailwind.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&display=swap');
    :root { --primary: #0f766e; }
    body { font-family: 'Inter', system-ui, sans-serif; -webkit-tap-highlight-color: transparent; }
    .title-font { font-family: 'Space Grotesk', sans-serif; }

    /* Light mode */
    html:not(.dark) body { background: #f4f4f5; color: #18181b; }
    html:not(.dark) .text-zinc-500 { color: #71717a; }
    html:not(.dark) .text-zinc-400 { color: #a1a1aa; }
    .glass { background: rgba(255,255,255,0.92); backdrop-filter: blur(20px); border: 1px solid rgba(0,0,0,0.06); }
    html:not(.dark) .glass { background: rgba(255,255,255,0.95); }

    /* Dark mode - fixed contrast and depth */
    .dark body { background: #0a0a0b; color: #fafafa; }
    .dark .glass { background: rgba(24,24,27,0.95); border: 1px solid rgba(63,63,70,0.8); backdrop-filter: blur(20px); }
    .dark .text-zinc-500 { color: #a1a1aa; }
    .dark .text-zinc-400 { color: #71717a; }
    .dark .text-zinc-600 { color: #a1a1aa; }
    .dark .border-zinc-200 { border-color: rgba(63,63,70,0.6); }
    .dark .border-zinc-700 { border-color: rgba(63,63,70,0.8); }
    .dark .border-zinc-800 { border-color: rgba(39,39,42,0.9); }
    .dark #theme-toggle { background: #27272a !important; border-color: rgba(63,63,70,0.9); }
    .dark #theme-toggle:hover { background: #3f3f46 !important; }

    /* Ocean gradient - shared by logo and site name */
    :root {
      --ocean-gradient: linear-gradient(135deg, #0d9488 0%, #0891b2 35%, #06b6d4 60%, #0284c7 100%);
      --ocean-gradient-dark: linear-gradient(135deg, #2dd4bf 0%, #22d3ee 40%, #38bdf8 70%, #0ea5e9 100%);
    }
    /* Header logo: gradient-filled SVG (mask), no gray background in light mode */
    .header-logo-wrap { background: transparent; }
    .header-logo-gradient {
      width: 100%;
      height: 100%;
      background: var(--ocean-gradient);
      -webkit-mask-image: url("./assets/svg/kapaa-surf-school-logo-wave.svg");
      mask-image: url("./assets/svg/kapaa-surf-school-logo-wave.svg");
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
    }
    .dark .header-logo-gradient { background: var(--ocean-gradient-dark); }
    .site-name-gradient {
      background: var(--ocean-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .dark .site-name-gradient {
      background: var(--ocean-gradient-dark);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .wave-canvas { filter: drop-shadow(0 15px 25px rgba(34,211,238,0.35)); }
    .leaflet-popup-content-wrapper { background: #0f172a; color: #e2e8f0; border: 1px solid #22d3ee; border-radius: 16px; }

    /* Mobile: prevent zoom on focus, safe area */
    @media (max-width: 767px) {
      input, select, textarea, button { font-size: 16px; }
    }
  </style>
</head>
<body class="min-h-screen bg-zinc-100 dark:bg-zinc-950 text-zinc-900 dark:text-zinc-100 pb-20 transition-colors duration-300">
  <header class="sticky top-0 z-50 glass border-b border-zinc-200 dark:border-zinc-800">
    <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 py-3 sm:py-5 flex flex-wrap items-center justify-between gap-3">
      <div class="flex items-center gap-3 min-w-0">
        <!-- Logo: gradient via SVG mask - mobile 393px first: 52px, then tablet, desktop -->
        <div class="header-logo-wrap flex items-center justify-center flex-shrink-0 w-[52px] h-[52px] sm:w-14 sm:h-14 md:w-16 md:h-16 overflow-visible" aria-hidden="true">
          <div class="header-logo-gradient w-full h-full"></div>
        </div>
        <div class="min-w-0">
          <span class="site-name-gradient title-font text-[1.5rem] sm:text-3xl md:text-4xl font-bold tracking-tighter block truncate">Kaua ªi Surf</span>
          <span class="block text-[10px] sm:text-xs tracking-[3px] sm:tracking-[4px] text-zinc-500 dark:text-zinc-400 -mt-0.5 sm:-mt-1">LIVE DASHBOARD</span>
        </div>
      </div>
      <div class="flex items-center gap-3 sm:gap-6 text-sm flex-shrink-0">
        <div id="live-time" class="font-mono text-sm sm:text-lg text-cyan-600 dark:text-cyan-400 hidden sm:block"></div>
        <button id="theme-toggle" type="button" class="w-11 h-11 sm:w-12 sm:h-12 min-w-[44px] min-h-[44px] flex items-center justify-center text-xl sm:text-2xl rounded-2xl border border-zinc-300 dark:border-zinc-600 bg-zinc-100 dark:bg-zinc-800 hover:bg-zinc-200 dark:hover:bg-zinc-700 active:scale-95 transition" aria-label="Toggle dark mode">‚òÄÔ∏è</button>
        <button onclick="refreshAllData()" class="flex items-center gap-2 sm:gap-3 px-4 sm:px-7 py-3 sm:py-3.5 min-h-[44px] bg-cyan-600 hover:bg-cyan-700 text-white rounded-2xl sm:rounded-3xl text-sm sm:text-base font-semibold transition active:scale-95">‚ü≥ Refresh</button>
      </div>
    </div>
  </header>

  <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 pt-4 sm:pt-10 pb-6">
    <!-- Hero (Kaua ªi Surf ‚Ä¢ AI Dashboard) -->
    <div class="glass rounded-2xl sm:rounded-3xl p-6 sm:p-10 mb-8 sm:mb-12">
      <div class="flex flex-col lg:flex-row gap-6 sm:gap-10 items-center">
        <div class="flex-1 w-full min-w-0">
          <div class="inline-flex items-center gap-2 px-3 sm:px-5 py-1.5 sm:py-2 bg-emerald-500/10 text-emerald-600 dark:text-emerald-400 rounded-2xl sm:rounded-3xl text-xs sm:text-sm font-medium mb-3 sm:mb-4">REAL-TIME ‚Ä¢ 8 BREAKS ‚Ä¢ NOAA POWERED</div>
          <h1 class="title-font text-3xl sm:text-5xl lg:text-7xl font-bold tracking-tighter leading-tight">Kaua ªi Surf ‚Ä¢ AI Dashboard</h1>
          <p class="mt-3 sm:mt-4 text-base sm:text-xl lg:text-2xl text-zinc-600 dark:text-zinc-400 max-w-lg">8 major breaks ‚Ä¢ Real NOAA tides ‚Ä¢ Face + Hawaiian wave heights ‚Ä¢ Swell direction & wind scoring per break</p>
        </div>
        <div class="grid grid-cols-3 gap-2 sm:gap-6 w-full lg:w-auto flex-shrink-0 min-w-0">
          <div class="glass rounded-2xl sm:rounded-3xl p-3 sm:p-6 text-center min-w-0 overflow-visible">
            <div class="text-[10px] sm:text-xs text-zinc-500 dark:text-zinc-400">WATER TEMP</div>
            <div id="water-temp" class="text-base sm:text-2xl lg:text-5xl font-bold text-cyan-500 dark:text-cyan-400 break-words">76¬∞F</div>
          </div>
          <div class="glass rounded-2xl sm:rounded-3xl p-3 sm:p-6 text-center min-w-0 overflow-visible">
            <div class="text-[10px] sm:text-xs text-zinc-500 dark:text-zinc-400">ISLAND TIDE</div>
            <div id="current-tide" class="text-base sm:text-2xl lg:text-5xl font-bold break-words">+1.4 ft</div>
          </div>
          <div class="glass rounded-2xl sm:rounded-3xl p-3 sm:p-6 text-center min-w-0 overflow-visible">
            <div class="text-[10px] sm:text-xs text-zinc-500 dark:text-zinc-400">WIND</div>
            <div id="overall-wind" class="text-base sm:text-2xl lg:text-5xl font-bold break-words">- mph</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Color scale legend: above cards, below main info card -->
    <div class="flex flex-wrap items-center justify-center gap-3 sm:gap-6 mb-6 sm:mb-8 text-xs text-zinc-600 dark:text-zinc-400">
      <div class="flex items-center gap-1.5"><div class="w-5 h-2 sm:w-6 sm:h-2.5 rounded bg-red-500"></div><span>1‚Äì3 Poor</span></div>
      <div class="flex items-center gap-1.5"><div class="w-5 h-2 sm:w-6 sm:h-2.5 rounded bg-orange-500"></div><span>4‚Äì5 Fair</span></div>
      <div class="flex items-center gap-1.5"><div class="w-5 h-2 sm:w-6 sm:h-2.5 rounded bg-yellow-400"></div><span>6‚Äì7 Good</span></div>
      <div class="flex items-center gap-1.5"><div class="w-5 h-2 sm:w-6 sm:h-2.5 rounded bg-emerald-500"></div><span>8‚Äì10 Epic</span></div>
    </div>

    <!-- Spots grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-4 sm:gap-6 mb-10 sm:mb-16" id="spots-grid"></div>

    <!-- Map beneath cards -->
    <div class="mb-10 sm:mb-16">
      <div class="flex flex-col sm:flex-row sm:justify-between sm:items-end gap-2 mb-3 sm:mb-4">
        <div class="title-font text-2xl sm:text-4xl font-semibold">Live Island Map ‚Ä¢ 8 Spots</div>
        <div class="text-sm text-zinc-500 dark:text-zinc-400">Tap marker or card for details</div>
      </div>
      <div id="kauai-map" class="w-full h-[280px] sm:h-[380px] md:h-[480px] lg:h-[520px] rounded-2xl sm:rounded-3xl overflow-hidden shadow-2xl border border-zinc-200 dark:border-zinc-700"></div>
    </div>
  </div>

  <!-- Detail Modal: full-screen on mobile, padded on desktop -->
  <div id="detail-modal" class="fixed inset-0 z-[100] hidden items-center justify-center p-0 sm:p-4 md:p-6 bg-black/80 overflow-hidden">
    <div class="glass w-full h-full sm:h-auto sm:max-h-[95vh] sm:max-w-7xl sm:rounded-3xl overflow-hidden flex flex-col">
      <div class="px-4 sm:px-8 py-4 sm:py-7 border-b border-zinc-200 dark:border-zinc-700 flex items-center justify-between flex-shrink-0 bg-white/90 dark:bg-zinc-900/95">
        <div class="flex items-center gap-3 sm:gap-6 min-w-0">
          <div id="modal-icon" class="text-4xl sm:text-6xl flex-shrink-0"></div>
          <div class="min-w-0">
            <div id="modal-name" class="title-font text-2xl sm:text-4xl font-bold truncate"></div>
            <div id="modal-facing" class="text-sm sm:text-lg text-zinc-500 dark:text-zinc-400 truncate"></div>
          </div>
        </div>
        <button type="button" onclick="closeModal()" class="flex-shrink-0 w-12 h-12 min-w-[48px] min-h-[48px] flex items-center justify-center text-4xl sm:text-5xl text-zinc-500 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-white active:scale-95 transition" aria-label="Close">√ó</button>
      </div>

      <div class="flex-1 overflow-auto p-4 sm:p-8 grid grid-cols-1 lg:grid-cols-12 gap-6 sm:gap-10">
        <div class="lg:col-span-7 space-y-8 sm:space-y-12">
          <div class="grid grid-cols-2 gap-3 sm:gap-4">
            <div id="modal-height-card" class="glass rounded-2xl sm:rounded-3xl p-5 sm:p-8"></div>
            <div id="modal-wind-card" class="glass rounded-2xl sm:rounded-3xl p-5 sm:p-8"></div>
          </div>

          <div>
            <div class="flex flex-wrap items-baseline justify-between gap-2 mb-3 sm:mb-4">
              <div class="text-base sm:text-xl font-semibold">Wave Cross-Section</div>
              <div id="modal-wave-desc" class="text-xs sm:text-sm text-emerald-600 dark:text-emerald-400 font-medium"></div>
            </div>
            <canvas id="wave-canvas" width="820" height="280" class="wave-canvas bg-gradient-to-b from-sky-950 to-slate-900 rounded-2xl sm:rounded-3xl w-full max-w-full"></canvas>
          </div>

          <div>
            <div class="text-base sm:text-xl font-semibold mb-3 sm:mb-4">Swell Direction</div>
            <div class="relative w-full min-h-[14rem] sm:min-h-[18rem] h-56 sm:h-72 rounded-2xl overflow-hidden border border-zinc-200 dark:border-zinc-700 bg-slate-900" style="min-height: 224px;">
              <div id="modal-swell-map" class="absolute inset-0 z-0 w-full h-full" style="min-height: 224px;"></div>
              <canvas id="modal-swell-flow" class="absolute inset-0 pointer-events-none w-full h-full" style="min-height: 224px; z-index: 650;"></canvas>
            </div>
            <div id="modal-swell-from" class="mt-2 text-sm text-zinc-500 dark:text-zinc-400"></div>
          </div>

          <div>
            <div class="flex flex-wrap justify-between gap-2 mb-3 sm:mb-4">
              <div class="text-base sm:text-xl font-semibold">Bathymetry Profile</div>
              <div class="text-xs text-zinc-500 dark:text-zinc-400">NOAA Chart 19381</div>
            </div>
            <canvas id="bathy-canvas" width="820" height="220" class="bg-slate-950 dark:bg-zinc-900 rounded-2xl sm:rounded-3xl w-full max-w-full"></canvas>
            <div id="modal-bathy-caption" class="mt-2 sm:mt-3 text-xs text-zinc-500 dark:text-zinc-400"></div>
          </div>
        </div>

        <div class="lg:col-span-5 space-y-6 sm:space-y-10">
          <div class="glass rounded-2xl sm:rounded-3xl p-6 sm:p-9 text-center">
            <div class="uppercase text-xs tracking-widest text-zinc-500 dark:text-zinc-400 mb-1">Surf Rating</div>
            <div id="modal-rating" class="text-6xl sm:text-8xl lg:text-9xl font-black title-font tracking-tighter leading-none"></div>
            <div id="modal-rating-label" class="text-xl sm:text-3xl font-medium mt-1"></div>
            <div class="mt-6 sm:mt-8 flex justify-center gap-6 sm:gap-12 text-sm">
              <div class="text-center"><div class="text-emerald-500 dark:text-emerald-400 text-xs">SWELL</div><div id="modal-swell-score" class="text-3xl sm:text-5xl font-bold"></div></div>
              <div class="text-center"><div class="text-amber-500 dark:text-amber-400 text-xs">WIND</div><div id="modal-wind-score" class="text-3xl sm:text-5xl font-bold"></div></div>
              <div class="text-center"><div class="text-cyan-500 dark:text-cyan-400 text-xs">TOTAL</div><div id="modal-total" class="text-3xl sm:text-5xl font-bold"></div></div>
            </div>
          </div>

          <div class="glass rounded-2xl sm:rounded-3xl p-5 sm:p-7">
            <div class="font-semibold mb-3 sm:mb-4">Detailed Scoring (V1)</div>
            <div id="advanced-metrics" class="space-y-3 sm:space-y-4 text-sm"></div>
          </div>

          <div class="glass rounded-2xl sm:rounded-3xl p-5 sm:p-7">
            <div class="font-semibold mb-3 sm:mb-4">Local Tide (NOAA)</div>
            <div id="modal-tide-info" class="space-y-2 text-sm"></div>
          </div>

          <div id="modal-insight" class="glass rounded-2xl sm:rounded-3xl p-5 sm:p-7 text-sm leading-relaxed"></div>
        </div>
      </div>
    </div>
  </div>

  <footer class="max-w-screen-2xl mx-auto px-4 sm:px-6 py-8 sm:py-12 text-xs border-t border-zinc-200 dark:border-zinc-800 text-zinc-500 dark:text-zinc-400 flex flex-wrap items-center justify-center sm:justify-start gap-x-3 gap-y-2 text-center sm:text-left">
    ¬© 2026 Phoenix Studios ‚Ä¢ Data: National Weather Service ‚Ä¢ NOAA Tides ‚Ä¢ Bathymetry (Chart 19381, NCEI DEM) ‚Ä¢ Made for the love of Kaua ªi ‚ù§Ô∏è‚Äçüî•
    <a href="https://damonphoenix.github.io" target="_blank" rel="noopener noreferrer" class="inline-flex items-center text-zinc-500 hover:text-zinc-900 dark:hover:text-zinc-100 transition-colors" aria-label="GitHub">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" class="inline-block"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
    </a>
  </footer>

  <script>
    // === 8 SPOTS - V1 schema (swellOpt, offshoreWind, tideStation) + bathy from full dashboard ===
    const spots = [
      { id:0, name:"Hanalei Bay", facing:"North", lat:22.2087, lon:-159.4920, color:"#22d3ee",
        idealHMin:3, idealHMax:9, swellOptMin:300, swellOptMax:60, offshoreWindMin:120, offshoreWindMax:210, tideStation:"1611683",
        bathyImg:"https://www.usharbors.com/wp-content/uploads/hanalei-bay-chart.jpg",
        bathyCaption:"Deep central channel + outer reef. Classic NW rights. NOAA 19381: reef 8-12 ft 150 yd out.",
        profileData: [[0,2],[80,8],[200,25],[400,45]] },
      { id:1, name:"Tunnels (Makua)", facing:"North", lat:22.2244, lon:-159.5603, color:"#22d3ee",
        idealHMin:4, idealHMax:10, swellOptMin:310, swellOptMax:40, offshoreWindMin:130, offshoreWindMax:200, tideStation:"1611683",
        bathyImg:"https://picsum.photos/id/1015/820/380",
        bathyCaption:"Lava tubes & outer reef drop-off. Steep to 40+ ft. Expert barrels.",
        profileData: [[0,3],[60,18],[150,42],[300,60]] },
      { id:2, name:"Cannons (Ha'ena)", facing:"North", lat:22.218, lon:-159.575, color:"#22d3ee",
        idealHMin:5, idealHMax:12, swellOptMin:310, swellOptMax:40, offshoreWindMin:130, offshoreWindMax:200, tideStation:"1611683",
        bathyImg:"https://picsum.photos/id/1016/820/380",
        bathyCaption:"Heavy lefts over shallow reef. Very steep bathymetry. High hazard.",
        profileData: [[0,4],[50,22],[120,55],[250,70]] },
      { id:3, name:"Anahola Bay", facing:"East", lat:22.148, lon:-159.305, color:"#67e8f9",
        idealHMin:2, idealHMax:7, swellOptMin:20, swellOptMax:100, offshoreWindMin:220, offshoreWindMax:300, tideStation:"1611400",
        bathyImg:"https://picsum.photos/id/133/820/380",
        bathyCaption:"Protected bay, sand + scattered reef. Great for all levels on NE trades.",
        profileData: [[0,1],[120,6],[300,18],[500,30]] },
      { id:4, name:"Kealia Beach", facing:"East", lat:22.0993, lon:-159.3045, color:"#67e8f9",
        idealHMin:3, idealHMax:7, swellOptMin:20, swellOptMax:100, offshoreWindMin:220, offshoreWindMax:300, tideStation:"1611400",
        bathyImg:"https://picsum.photos/id/201/820/380",
        bathyCaption:"Long sandbar + reef mix. Consistent beach break. Gradual slope.",
        profileData: [[0,2],[150,9],[350,22],[600,35]] },
      { id:5, name:"Kalapaki Beach", facing:"South", lat:21.9604, lon:-159.3505, color:"#eab308",
        idealHMin:1, idealHMax:5, swellOptMin:135, swellOptMax:225, offshoreWindMin:330, offshoreWindMax:60, tideStation:"1611400",
        bathyImg:"https://picsum.photos/id/251/820/380",
        bathyCaption:"Protected bay reef. Small consistent waves. Shallow near jetty.",
        profileData: [[0,3],[100,7],[250,15],[450,28]] },
      { id:6, name:"Shipwreck (Maha'ulepu)", facing:"South", lat:21.8744, lon:-159.4386, color:"#eab308",
        idealHMin:2, idealHMax:6, swellOptMin:135, swellOptMax:225, offshoreWindMin:330, offshoreWindMax:60, tideStation:"1611400",
        bathyImg:"https://www.usharbors.com/wp-content/uploads/poipu-area-chart.jpg",
        bathyCaption:"Fringing reef + sand channels. Playful rights & lefts.",
        profileData: [[0,2],[90,12],[220,28],[400,45]] },
      { id:7, name:"PK's / Centers (Poipu)", facing:"South", lat:21.8792, lon:-159.4776, color:"#eab308",
        idealHMin:2, idealHMax:6, swellOptMin:135, swellOptMax:225, offshoreWindMin:330, offshoreWindMax:60, tideStation:"1611400",
        bathyImg:"https://www.usharbors.com/wp-content/uploads/poipu-area-chart.jpg",
        bathyCaption:"Classic south shore reef. Multiple peaks. Sand pockets.",
        profileData: [[0,3],[110,10],[240,25],[420,38]] }
    ];

    let map, allSpotData = [];
    let modalSwellMap = null;
    let modalSwellFlowAnimId = null;

    // One NWS grid point per coast so all north (or east/south) breaks share the same swell
    const coastPoints = {
      North: { lat: 22.2244, lon: -159.5603 },
      East:  { lat: 22.148,  lon: -159.305 },
      South: { lat: 21.8792, lon: -159.4776 }
    };

    // --- V1 RATING (decision-maker for good waves or not) ---
    function angleDiff(a, b) { const d = Math.abs(a - b) % 360; return Math.min(d, 360 - d); }
    function swellDirFrom(apiDir) {
      if (apiDir == null || isNaN(apiDir)) return null;
      return ((apiDir + 180) % 360);
    }
    function swellDirScore(dir, spot) {
      const from = swellDirFrom(dir);
      if (from == null) return 5;
      const inRange = (spot.swellOptMax > spot.swellOptMin) ? (from >= spot.swellOptMin && from <= spot.swellOptMax) : (from >= spot.swellOptMin || from <= spot.swellOptMax);
      if (inRange) return 10;
      const minD = Math.min(angleDiff(from, spot.swellOptMin), angleDiff(from, spot.swellOptMax));
      return Math.max(1, 10 - minD * 0.25);
    }
    function windScore(speedKts, dir, spot) {
      const speedScore = Math.max(1, 10 - speedKts * 0.65);
      let dirDelta = 999;
      if (spot.offshoreWindMax > spot.offshoreWindMin) { if (dir >= spot.offshoreWindMin && dir <= spot.offshoreWindMax) dirDelta = 0; }
      else { if (dir >= spot.offshoreWindMin || dir <= spot.offshoreWindMax) dirDelta = 0; }
      if (dirDelta === 999) dirDelta = Math.min(angleDiff(dir, spot.offshoreWindMin), angleDiff(dir, spot.offshoreWindMax));
      const dirScore = Math.max(1, 10 - dirDelta * 0.18);
      return speedScore * 0.6 + dirScore * 0.4;
    }
    function heightScore(hFt, spot) {
      if (hFt < 0.5) return 1;
      if (hFt < 1) return 2;
      if (hFt <= spot.idealHMin) return 4 + (hFt - 1) * 2;
      if (hFt <= spot.idealHMax) {
        const range = spot.idealHMax - spot.idealHMin;
        if (range <= 0) return 10;
        const mid = spot.idealHMin + range * 0.5;
        if (hFt <= mid) return 6 + 4 * (hFt - spot.idealHMin) / (mid - spot.idealHMin);
        return 10 - 2 * (hFt - mid) / (spot.idealHMax - mid);
      }
      if (hFt <= spot.idealHMax + 4) return 10 - (hFt - spot.idealHMax) * 1.2;
      return 3;
    }

    function maxRatingForHeight(hFt) {
      if (hFt < 0.5) return 1;
      if (hFt < 1) return 2;
      if (hFt < 1.5) return 4;
      if (hFt < 2) return 6;
      return 10;
    }
    function periodScore(p) {
      if (p < 8) return 3;
      if (p < 10) return 6;
      if (p < 12) return 9;
      if (p < 14) return 9.5;
      return 10;
    }
    function toFt(m) { return m ? (m * 3.28084).toFixed(1) : "0"; }
    function toKts(ms) { return ms ? (ms * 1.94384).toFixed(0) : "0"; }

    function calculateRating(data, spot) {
      const h = parseFloat(toFt(data.waveHeight || data.primarySwellHeight || 0));
      const period = data.wavePeriod || 0;
      const swellDirApi = data.primarySwellDirection ?? data.waveDirection ?? 0;
      const windSpeedKts = parseFloat(data.windSpeed) || 0;
      const windDir = data.windDirection || 0;
      const hScore = heightScore(h, spot);
      const pScore = periodScore(period);
      const dScore = swellDirScore(swellDirApi, spot);
      const wScore = windScore(windSpeedKts, windDir, spot);
      const swellTotal = hScore * 0.35 + pScore * 0.35 + dScore * 0.30;
      const rawTotal = swellTotal * 0.55 + wScore * 0.35;
      const cap = maxRatingForHeight(h);
      const total = Math.min(cap, Math.min(10, Math.max(1, Math.round(rawTotal))));
      return {
        total: Math.max(1, total),
        swellScore: Math.round(swellTotal),
        windScore: Math.round(wScore),
        hFt: (data.waveHeight != null ? (data.waveHeight * 3.28084).toFixed(1) : "-")
      };
    }

    // NWS fetch (forecastGridData) - one point per coast so Hanalei/Tunnels etc. share same swell
    function valueForNow(arr) {
      if (!arr?.values?.length) return null;
      const now = Date.now();
      for (const item of arr.values) {
        const vt = item.validTime || "";
        const m = vt.match(/^([^/]+)\/(PT\d+H)?(PT\d+M)?$/);
        if (!m) continue;
        const start = new Date(m[1].trim()).getTime();
        if (isNaN(start)) continue;
        const hours = (m[2] && parseInt(m[2].replace(/\D/g, ""), 10)) || 0;
        const mins = (m[3] && parseInt(m[3].replace(/\D/g, ""), 10)) || 0;
        const end = start + (hours * 60 + mins) * 60 * 1000;
        if (now >= start && now < end) return item.value;
      }
      return arr.values[0]?.value ?? null;
    }

    function rawWindToKt(raw, uom) {
      if (raw == null || isNaN(raw)) return 0;
      const u = String(uom || "").toLowerCase();
      if (u.includes("km") || u.includes("km_h")) return raw / 1.852;
      if (u.includes("m_s") || u.includes("m/s")) return raw * 1.94384;
      const asMs = raw * 1.94384;
      if (asMs > 50) return raw / 1.852;
      return asMs;
    }

    async function fetchCoastData(lat, lon) {
      try {
        const ua = { "User-Agent": "KauaiSurfDashboard/3.0 (aloha@kapaasurfschool.com)" };
        const point = await (await fetch(`https://api.weather.gov/points/${lat},${lon}`, { headers: ua })).json();
        const grid = await (await fetch(point.properties.forecastGridData, { headers: ua })).json();
        const p = grid.properties || {};
        const v = (arr) => (valueForNow(arr) ?? 0);
        const rawWind = valueForNow(p.windSpeed);
        const windSpeedKts = rawWindToKt(rawWind, p.windSpeed?.uom);
        return {
          waveHeight: v(p.waveHeight),
          wavePeriod: v(p.wavePeriod),
          waveDirection: v(p.waveDirection),
          primarySwellHeight: v(p.primarySwellHeight),
          primarySwellDirection: v(p.primarySwellDirection),
          windSpeed: windSpeedKts,
          windDirection: v(p.windDirection)
        };
      } catch (e) { return null; }
    }

    async function fetchSpotData(spot) {
      const coast = coastPoints[spot.facing];
      return coast ? fetchCoastData(coast.lat, coast.lon) : null;
    }

    function getTodayHawaii() {
      return new Date().toLocaleDateString('en-CA', { timeZone: 'Pacific/Honolulu' }).replace(/-/g, '');
    }

    function parseNoaaTime(t) {
      if (!t) return NaN;
      const s = String(t).trim();
      const m = s.match(/^(\d{4})-?(\d{2})-?(\d{2})[\sT]+(\d{1,2}):?(\d{2})/);
      if (m) {
        const y = +m[1], mo = +m[2] - 1, d = +m[3], h = +m[4], min = +m[5];
        return Date.UTC(y, mo, d, h + 10, min, 0, 0);
      }
      const d = new Date(s);
      return isNaN(d.getTime()) ? NaN : d.getTime();
    }

    async function fetchNoaaJson(url) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(res.statusText);
        return await res.json();
      } catch (e) {
        try {
          const proxy = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
          const res = await fetch(proxy);
          if (!res.ok) return null;
          const text = await res.text();
          return text ? JSON.parse(text) : null;
        } catch (e2) { return null; }
      }
    }

    async function fetchTide(station) {
      const today = getTodayHawaii();
      const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=water_level&begin_date=${today}&end_date=${today}&datum=MLLW&station=${station}&time_zone=lst&units=english&format=json`;
      const json = await fetchNoaaJson(url);
      if (!json || json.error) return null;
      const data = json.data || [];
      return Array.isArray(data) ? data : [];
    }

    function getCurrentTideFromData(tideData) {
      if (!tideData || !Array.isArray(tideData) || tideData.length === 0) return null;
      const now = new Date().getTime();
      const parse = (d) => parseNoaaTime(d.t || d.dateTime);
      const getV = (d) => parseFloat(d.v);
      const sorted = tideData.slice().filter(d => !isNaN(parse(d))).sort((a, b) => parse(a) - parse(b));
      if (sorted.length === 0) {
        const last = tideData[tideData.length - 1];
        return last && last.v != null ? getV(last) : null;
      }
      if (sorted.length === 1) return getV(sorted[0]);
      let i = 0;
      while (i < sorted.length && parse(sorted[i]) < now) i++;
      if (i === 0) return getV(sorted[0]);
      if (i >= sorted.length) return getV(sorted[sorted.length - 1]);
      const t0 = parse(sorted[i - 1]), t1 = parse(sorted[i]);
      const v0 = getV(sorted[i - 1]), v1 = getV(sorted[i]);
      const frac = (t1 - t0) ? (now - t0) / (t1 - t0) : 0;
      return v0 + frac * (v1 - v0);
    }

    async function fetchWaterTemp(station) {
      const today = getTodayHawaii();
      const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=water_temperature&begin_date=${today}&end_date=${today}&station=${station}&time_zone=lst&units=english&format=json`;
      const json = await fetchNoaaJson(url);
      if (!json || json.error) return null;
      const data = json.data || [];
      if (!Array.isArray(data) || data.length === 0) return null;
      const latest = data[data.length - 1];
      const v = parseFloat(latest.v);
      return isNaN(v) ? null : v;
    }

    function windDirToCompass(deg) {
      if (deg == null || isNaN(deg)) return "-";
      const dirs = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      const i = Math.round(((deg % 360) + 360) % 360 / 22.5) % 16;
      return dirs[i];
    }

    function hawaiianScale(faceFt) {
      return Math.round(parseFloat(faceFt) * 0.6);
    }

    function getRatingColor(r) {
      if (r >= 8) return '#10b981';
      if (r >= 6) return '#eab308';
      if (r >= 4) return '#f59e0b';
      return '#ef4444';
    }

    function drawSwellCompass(dir) {
      const svg = document.getElementById('swell-compass');
      if (!svg) return;
      svg.innerHTML = `
        <circle cx="80" cy="80" r="75" fill="none" stroke="currentColor" stroke-width="8"/>
        <text x="80" y="25" text-anchor="middle" fill="currentColor" font-size="14">N</text>
        <text x="80" y="145" text-anchor="middle" fill="currentColor" font-size="14">S</text>
        <text x="15" y="85" text-anchor="middle" fill="currentColor" font-size="14">W</text>
        <text x="145" y="85" text-anchor="middle" fill="currentColor" font-size="14">E</text>
        <line x1="80" y1="80" x2="80" y2="20" stroke="#22d3ee" stroke-width="6" stroke-linecap="round"/>
        <polygon points="70,30 80,15 90,30" fill="#22d3ee"/>
        <text x="80" y="115" text-anchor="middle" fill="#67e8f9" font-size="18" font-weight="700">${Math.round(dir)}¬∞</text>
      `;
      const line = svg.querySelector('line');
      const poly = svg.querySelector('polygon');
      if (line) line.setAttribute('transform', `rotate(${dir} 80 80)`);
      if (poly) poly.setAttribute('transform', `rotate(${dir} 80 80)`);
    }

    function drawWaveCrossSection(canvas, heightFt, period, swellScore) {
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      let frame = 0;
      const scr = Math.max(1, Math.min(10, swellScore));
      const amp = Math.max(18, (heightFt || 2) * 7.5) * (scr / 10 + 0.4);
      const wavelength = 420 / (period / 12 || 1);

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, "#164e63");
        grad.addColorStop(1, "#0f172a");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#334155";
        ctx.fillRect(0, canvas.height - 55, canvas.width, 55);
        ctx.shadowBlur = 30;
        ctx.shadowColor = scr >= 7 ? "#67e8f9" : "#22d3ee";
        ctx.strokeStyle = "#67e8f9";
        ctx.lineWidth = scr >= 7 ? 9 : 6;
        ctx.beginPath();
        for (let x = 0; x < canvas.width + 200; x += 3) {
          const y = canvas.height * 0.48 + Math.sin((x + frame * 5) / wavelength) * amp * (1 + Math.sin(x / 180) * 0.2);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
        if (scr >= 6) {
          ctx.strokeStyle = "rgba(224,242,254,0.95)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let x = 0; x < canvas.width + 200; x += 5) {
            const y = canvas.height * 0.48 + Math.sin((x + frame * 5) / wavelength) * amp * (1 + Math.sin(x / 180) * 0.2) - 14;
            ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        frame += 1.4;
        requestAnimationFrame(animate);
      }
      animate();
    }

    function drawBathyProfile(canvas, profileData) {
      if (!canvas || !profileData) return;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#1e2937";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const maxDist = 600, maxDepth = 80;
      ctx.strokeStyle = "#67e8f9";
      ctx.lineWidth = 5;
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#67e8f9";
      ctx.beginPath();
      ctx.moveTo(40, canvas.height - 40);
      profileData.forEach(([dist, depth]) => {
        const x = 40 + (dist / maxDist) * (canvas.width - 80);
        const y = canvas.height - 40 - (depth / maxDepth) * (canvas.height - 80);
        ctx.lineTo(x, y);
      });
      ctx.lineTo(canvas.width - 40, canvas.height - 40);
      ctx.stroke();
      ctx.fillStyle = "#e2e8f0";
      ctx.font = "12px Inter";
      ctx.fillText("Shore", 50, canvas.height - 15);
      ctx.fillText("Offshore 600 yd", canvas.width - 130, canvas.height - 15);
    }

    function renderCard(spot, data, ratingInfo) {
      const container = document.getElementById("spots-grid");
      if (!container) return;
      const face = data ? ratingInfo.hFt : "-";
      const hawaiian = data ? hawaiianScale(face) : "-";
      const r = ratingInfo ? ratingInfo.total : "-";
      const color = typeof r === "number" ? getRatingColor(r) : spot.color;
      const cardHTML = `
        <div onclick="openModal(${spot.id})" data-spot-id="${spot.id}" class="glass rounded-2xl sm:rounded-3xl p-5 sm:p-7 cursor-pointer hover:-translate-y-1 active:scale-[0.99] transition-all min-h-[120px] touch-manipulation" role="button" tabindex="0">
          <div class="flex justify-between items-start gap-2">
            <div class="min-w-0">
              <div class="font-semibold text-lg sm:text-2xl truncate">${spot.name}</div>
              <div class="text-xs text-zinc-500 dark:text-zinc-400">${spot.facing} facing</div>
            </div>
            <div class="text-right flex-shrink-0">
              <div class="text-5xl sm:text-6xl font-black leading-none" style="color:${color}">${r}</div>
              <div class="text-xs -mt-0.5 text-zinc-500 dark:text-zinc-400">/10</div>
            </div>
          </div>
          <div class="my-4 sm:my-6 h-12 sm:h-14">
            <canvas id="mini-${spot.id}" width="260" height="56" class="wave-canvas w-full max-w-full h-full object-contain"></canvas>
          </div>
          <div class="flex justify-between text-xs sm:text-sm">
            <div><span class="text-zinc-500 dark:text-zinc-400">Face:</span> <span class="font-medium">${face} ft</span></div>
            <div><span class="text-zinc-500 dark:text-zinc-400">Hawaiian:</span> <span class="font-medium">${hawaiian} ft</span></div>
          </div>
        </div>`;
      const div = document.createElement("div");
      div.innerHTML = cardHTML;
      container.appendChild(div.firstElementChild);

      setTimeout(() => {
        const mini = document.getElementById(`mini-${spot.id}`);
        if (mini && data) {
          const mctx = mini.getContext("2d");
          const f = parseFloat(face);
          if (!isNaN(f)) {
            mctx.strokeStyle = "#67e8f9";
            mctx.lineWidth = 3;
            mctx.beginPath();
            for (let x = 0; x < mini.width; x += 3) {
              const y = 28 + Math.sin(x / 25) * (f * 1.8);
              if (x === 0) mctx.moveTo(x, y); else mctx.lineTo(x, y);
            }
            mctx.stroke();
          }
        }
      }, 100);
    }

    async function openModal(id) {
      const entry = allSpotData.find(e => e.spot.id === id);
      if (!entry) return;
      const { spot, data, ratingInfo } = entry;
      const modal = document.getElementById("detail-modal");
      modal.classList.remove("hidden");
      modal.classList.add("flex");
      document.body.style.overflow = "hidden";
      const onEscape = (e) => { if (e.key === "Escape") { closeModal(); document.removeEventListener("keydown", onEscape); } };
      document.addEventListener("keydown", onEscape);

      document.getElementById("modal-name").textContent = spot.name;
      document.getElementById("modal-facing").textContent = `${spot.facing} facing ‚Ä¢ ${(spot.bathyCaption || "").split('.')[0]}`;
      document.getElementById("modal-icon").textContent = spot.facing === "North" ? "üèÑ‚Äç‚ôÇÔ∏è" : spot.facing === "South" ? "üåä" : "üèùÔ∏è";

      const face = ratingInfo.hFt;
      const hawaiian = hawaiianScale(face);

      document.getElementById("modal-height-card").innerHTML = `
        <div class="text-xs text-zinc-400">WAVE HEIGHT</div>
        <div class="text-6xl font-bold">${face} ft <span class="text-base align-super text-zinc-400">face</span></div>
        <div class="text-xl text-emerald-400">${hawaiian} ft Hawaiian scale</div>
      `;

      const windMph = data ? Math.round(data.windSpeed * 1.15078) : "-";
      const windDir = data ? Math.round(data.windDirection || 0) : "-";
      document.getElementById("modal-wind-card").innerHTML = `
        <div class="text-xs text-zinc-400">WIND</div>
        <div class="text-6xl font-bold">${windMph} mph</div>
        <div class="text-sm">${windDir}¬∞</div>
      `;

      const r = ratingInfo.total;
      const label = r >= 8 ? "EPIC" : r >= 6 ? "EXCELLENT" : r >= 4 ? "GOOD" : "FAIR";
      const color = getRatingColor(r);
      document.getElementById("modal-rating").style.color = color;
      document.getElementById("modal-rating").textContent = r;
      document.getElementById("modal-rating-label").innerHTML = `<span style="color:${color}">${label}</span>`;
      document.getElementById("modal-swell-score").textContent = ratingInfo.swellScore;
      document.getElementById("modal-wind-score").textContent = ratingInfo.windScore;
      document.getElementById("modal-total").textContent = r;

      document.getElementById("modal-wave-desc").textContent = `${face} ft @ ${data ? (data.wavePeriod || "-") : "-"}s`;
      drawWaveCrossSection(document.getElementById("wave-canvas"), parseFloat(face) || 2, data ? data.wavePeriod : 8, ratingInfo.swellScore);

      if (spot.profileData) {
        drawBathyProfile(document.getElementById("bathy-canvas"), spot.profileData);
      }
      document.getElementById("modal-bathy-caption").textContent = spot.bathyCaption || "";

      const swellFrom = data ? swellDirFrom(data.primarySwellDirection ?? data.waveDirection ?? 0) : null;
      const swellFromVal = swellFrom != null ? swellFrom : 0;
      const swellFromEl = document.getElementById("modal-swell-from");
      if (swellFromEl) swellFromEl.textContent = data ? `${Math.round(swellFromVal)}¬∞ (${windDirToCompass(swellFromVal)})` : "-";
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          setTimeout(() => initModalSwellMap(spot, swellFromVal), 80);
        });
      });
      if (data) {
        const h = parseFloat((data.waveHeight * 3.28084).toFixed(1));
        const hSc = heightScore(h, spot);
        const pSc = periodScore(data.wavePeriod || 0);
        const dSc = swellDirScore(data.primarySwellDirection ?? data.waveDirection ?? 0, spot);
        const wSc = windScore(parseFloat(data.windSpeed) || 0, data.windDirection || 0, spot);
        document.getElementById("advanced-metrics").innerHTML = `
          <div class="flex justify-between"><span>Height score</span><span class="font-semibold">${Math.round(hSc)}/10</span></div>
          <div class="flex justify-between"><span>Period score</span><span class="font-semibold">${Math.round(pSc)}/10</span></div>
          <div class="flex justify-between"><span>Direction match</span><span class="font-semibold">${Math.round(dSc)}/10</span></div>
          <div class="flex justify-between"><span>Wind cleanliness</span><span class="font-semibold">${Math.round(wSc)}/10</span></div>
        `;
      }

      const tideData = await fetchTide(spot.tideStation);
      const tideEl = document.getElementById("modal-tide-info");
      if (tideData && tideData.length) {
        const next8 = tideData.slice(0, 8);
        tideEl.innerHTML = next8.map(t => `<div class="flex justify-between"><span>${t.t}</span><span class="font-medium">${t.v} ft</span></div>`).join('');
      } else {
        tideEl.innerHTML = '<div class="text-amber-500">Tide data unavailable</div>';
      }

      let insight = r >= 8 ? "Prime conditions. Clean, powerful, lined up. Go now." : r >= 6 ? "Very surfable. Offshore winds holding it together." : "Smaller or choppy. Longboard or protected zones.";
      if (spot.name === "Tunnels" || spot.name === "Cannons") insight += " Watch for strong rip currents.";
      else insight += " Watch for tide push.";
      document.getElementById("modal-insight").innerHTML = `<strong>Pro tip:</strong> ${insight}`;
    }

    function closeModal() {
      teardownModalSwellMap();
      document.getElementById("detail-modal").classList.add("hidden");
      document.getElementById("detail-modal").classList.remove("flex");
      document.body.style.overflow = "";
    }

    async function renderAllCards() {
      const grid = document.getElementById("spots-grid");
      if (!grid) return;
      grid.innerHTML = "";
      allSpotData = [];
      const coastData = {};
      for (const facing of ["North", "East", "South"]) {
        const coast = coastPoints[facing];
        if (coast) coastData[facing] = await fetchCoastData(coast.lat, coast.lon);
      }
      for (const spot of spots) {
        const data = coastData[spot.facing] || null;
        const ratingInfo = data ? calculateRating(data, spot) : { total: "-", swellScore: "-", windScore: "-", hFt: "-" };
        allSpotData.push({ spot, data, ratingInfo });
        renderCard(spot, data, ratingInfo);
      }
    }

    function initMap() {
      map = L.map('kauai-map', {
        minZoom: 9.5,
        maxZoom: 15,
        maxBounds: L.latLngBounds(L.latLng(21.65, -160.0), L.latLng(22.45, -159.0)),
        maxBoundsViscosity: 1.0
      }).setView([22.05, -159.5], 10.5);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      spots.forEach(s => {
        L.circleMarker([s.lat, s.lon], { radius: 11, fillColor: s.color, color: '#fff', weight: 3, fillOpacity: 0.9 })
          .addTo(map)
          .bindPopup(`<b>${s.name}</b><br>${s.facing} facing`)
          .on('click', () => openModal(s.id));
      });
    }

    // Kauai land polygon [lat, lon] - coastline so ocean (outside) fills the view
    const KAUAI_LAND_POLYGON = [
      [22.23, -159.96], [22.23, -159.55], [22.22, -159.38], [22.20, -159.35], [22.18, -159.32], [22.0, -159.28],
      [21.87, -159.42], [21.86, -159.72], [21.90, -159.92], [22.06, -159.98], [22.20, -159.95]
    ];
    function pointInPolygon(lat, lon, polygon) {
      let inside = false;
      const n = polygon.length;
      for (let i = 0, j = n - 1; i < n; j = i++) {
        const yi = polygon[i][0], xi = polygon[i][1];
        const yj = polygon[j][0], xj = polygon[j][1];
        if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) inside = !inside;
      }
      return inside;
    }

    function startModalSwellFlow(canvas, swellFromDeg, map) {
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const toward = (swellFromDeg + 180) % 360;
      const rad = toward * Math.PI / 180;
      const dx = Math.sin(rad);
      const dy = -Math.cos(rad);
      const speed = 0.6;
      const count = 80;
      const crestHalfLen = 6;
      const refracRadius = 0.018;  // degrees - distance from coast where refraction blends in
      let particles = [];
      let lastW = 400, lastH = 224;
      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        let w = canvas.clientWidth || canvas.offsetWidth;
        let h = canvas.clientHeight || canvas.offsetHeight;
        if (w < 10 || h < 10) {
          w = lastW;
          h = lastH;
        }
        lastW = w;
        lastH = h;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";
        particles = [];
        for (let i = 0; i < count; i++) {
          particles.push({ x: Math.random() * w, y: Math.random() * h });
        }
      };
      resize();
      const animate = () => {
        let w = canvas.clientWidth || canvas.offsetWidth || lastW;
        let h = canvas.clientHeight || canvas.offsetHeight || lastH;
        if (w < 10 || h < 10) { w = lastW; h = lastH; }
        const dpr = window.devicePixelRatio || 1;
        if (canvas.width !== w * dpr || canvas.height !== h * dpr) resize();
        ctx.clearRect(0, 0, w, h);
        const isDark = document.documentElement.classList.contains("dark");
        for (const p of particles) {
          let ldx = dx, ldy = dy;
          let overLand = false;
          if (map) {
            const mapContainer = map.getContainer();
            const mapW = mapContainer.offsetWidth || w;
            const mapH = mapContainer.offsetHeight || h;
            const px = (mapW !== w) ? (p.x * mapW / w) : p.x;
            const py = (mapH !== h) ? (p.y * mapH / h) : p.y;
            const ll = map.containerPointToLatLng(L.point(px, py));
            overLand = pointInPolygon(ll.lat, ll.lng, KAUAI_LAND_POLYGON);
            if (!overLand) {
              const coast = nearestCoastEdge(ll.lat, ll.lng, KAUAI_LAND_POLYGON, map);
              const blend = Math.max(0, 1 - coast.dist / refracRadius);
              if (blend > 0.01) {
                const tx = coast.tx, ty = coast.ty;
                const perp1x = -ty, perp1y = tx;
                const perp2x = ty, perp2y = -tx;
                // Refraction bends wave TOWARD the coast (shallower water). Pick perpendicular that points toward coast.
                let towardCoastX = coast.coastX - px, towardCoastY = coast.coastY - py;
                const tcLen = Math.sqrt(towardCoastX * towardCoastX + towardCoastY * towardCoastY) || 1e-9;
                towardCoastX /= tcLen;
                towardCoastY /= tcLen;
                const dot1 = towardCoastX * perp1x + towardCoastY * perp1y;
                const perpx = dot1 >= 0 ? perp1x : perp2x;
                const perpy = dot1 >= 0 ? perp1y : perp2y;
                ldx = dx * (1 - blend) + perpx * blend;
                ldy = dy * (1 - blend) + perpy * blend;
                const len = Math.sqrt(ldx * ldx + ldy * ldy) || 1e-9;
                ldx /= len;
                ldy /= len;
              }
            }
          }
          p.x += ldx * speed;
          p.y += ldy * speed;
          if (p.x < -crestHalfLen) p.x += w + crestHalfLen * 2;
          if (p.x > w + crestHalfLen) p.x -= w + crestHalfLen * 2;
          if (p.y < -crestHalfLen) p.y += h + crestHalfLen * 2;
          if (p.y > h + crestHalfLen) p.y -= h + crestHalfLen * 2;
          if (overLand) continue;
          ctx.strokeStyle = isDark ? "rgba(34, 211, 238, 0.9)" : "rgba(6, 182, 212, 0.85)";
          ctx.lineWidth = 2.5;
          ctx.lineCap = "round";
          ctx.shadowColor = isDark ? "#22d3ee" : "#06b6d4";
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.moveTo(p.x - ldy * crestHalfLen, p.y + ldx * crestHalfLen);
          ctx.lineTo(p.x + ldy * crestHalfLen, p.y - ldx * crestHalfLen);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        modalSwellFlowAnimId = requestAnimationFrame(animate);
      };
      animate();
    }

    function initModalSwellMap(spot, swellFromDeg) {
      if (modalSwellMap) {
        modalSwellMap.remove();
        modalSwellMap = null;
      }
      if (modalSwellFlowAnimId) {
        cancelAnimationFrame(modalSwellFlowAnimId);
        modalSwellFlowAnimId = null;
      }
      const container = document.getElementById("modal-swell-map");
      const canvas = document.getElementById("modal-swell-flow");
      if (!container) return;
      const wrapper = container.parentElement;
      if (wrapper) {
        const w = wrapper.offsetWidth || wrapper.clientWidth || 400;
        const h = wrapper.offsetHeight || wrapper.clientHeight || 224;
        container.style.width = w + "px";
        container.style.height = h + "px";
      }
      modalSwellMap = L.map(container, {
        center: [spot.lat, spot.lon],
        zoom: 12,
        zoomControl: false,
        dragging: false,
        touchZoom: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        attributionControl: false
      });
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(modalSwellMap);
      L.circleMarker([spot.lat, spot.lon], {
        radius: 10,
        fillColor: spot.color || "#22d3ee",
        color: "#fff",
        weight: 2,
        fillOpacity: 0.95
      }).addTo(modalSwellMap);
      modalSwellMap.invalidateSize();
      setTimeout(() => {
        if (modalSwellMap) modalSwellMap.invalidateSize();
      }, 200);
      if (canvas && wrapper) {
        const cw = wrapper.offsetWidth || 400;
        const ch = wrapper.offsetHeight || 224;
        canvas.style.width = cw + "px";
        canvas.style.height = ch + "px";
        startModalSwellFlow(canvas, swellFromDeg != null ? swellFromDeg : 0, modalSwellMap);
      }
    }

    function teardownModalSwellMap() {
      if (modalSwellFlowAnimId) {
        cancelAnimationFrame(modalSwellFlowAnimId);
        modalSwellFlowAnimId = null;
      }
      if (modalSwellMap) {
        modalSwellMap.remove();
        modalSwellMap = null;
      }
    }

    function updateLiveTime() {
      const el = document.getElementById("live-time");
      if (el) {
        function tick() {
          el.textContent = new Date().toLocaleString("en-US", { timeZone: "Pacific/Honolulu", hour: "numeric", minute: "2-digit", second: "2-digit", hour12: true }) + " HST";
        }
        tick();
        setInterval(tick, 1000);
      }
    }

    const HERO_TIDE_STATION = "1611400";
    const HERO_WATER_TEMP_STATION = "1611400";

    async function updateHeroFromLiveData() {
      const wtEl = document.getElementById("water-temp");
      const ctEl = document.getElementById("current-tide");
      const owEl = document.getElementById("overall-wind");
      const windData = spots.length ? await fetchSpotData(spots[0]) : null;
      if (owEl) {
        if (windData) {
          const mph = Math.round(windData.windSpeed * 1.15078);
          const compass = windDirToCompass(windData.windDirection);
          owEl.textContent = `${compass} ${mph} mph`;
        } else owEl.textContent = "-";
      }
      try {
        const tideData = await fetchTide(HERO_TIDE_STATION);
        const currentFt = getCurrentTideFromData(tideData);
        if (ctEl) ctEl.textContent = currentFt != null ? `${currentFt >= 0 ? "+" : ""}${currentFt.toFixed(1)} ft` : "-";
      } catch (e) { if (ctEl) ctEl.textContent = "-"; }
      try {
        let tempF = await fetchWaterTemp(HERO_WATER_TEMP_STATION);
        if (tempF == null && HERO_WATER_TEMP_STATION !== "1611683") tempF = await fetchWaterTemp("1611683");
        if (wtEl) wtEl.textContent = tempF != null ? `${Math.round(tempF)}¬∞F` : "-";
      } catch (e) { if (wtEl) wtEl.textContent = "-"; }
    }

    async function refreshAllData() {
      const grid = document.getElementById("spots-grid");
      if (grid) grid.innerHTML = '<div class="col-span-4 text-center py-24 text-zinc-400">Pulling fresh NOAA data for all 8 breaks...</div>';
      await renderAllCards();
      await updateHeroFromLiveData();
    }

    function updateThemeButton() {
      const btn = document.getElementById("theme-toggle");
      const isDark = document.documentElement.classList.contains("dark");
      btn.textContent = isDark ? "‚òÄÔ∏è" : "üåô";
      btn.setAttribute("aria-label", isDark ? "Switch to light mode" : "Switch to dark mode");
    }
    document.getElementById("theme-toggle").addEventListener("click", () => {
      document.documentElement.classList.toggle("dark");
      updateThemeButton();
    });

    document.getElementById("spots-grid").addEventListener("keydown", (e) => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const card = e.target.closest("[data-spot-id]");
      if (!card) return;
      e.preventDefault();
      openModal(parseInt(card.getAttribute("data-spot-id"), 10));
    });

    async function initializeDashboard() {
      updateThemeButton();
      updateLiveTime();
      initMap();
      await renderAllCards();
      await updateHeroFromLiveData();
      setInterval(refreshAllData, 900000);
      setInterval(updateHeroFromLiveData, 60000);
    }

    window.onload = initializeDashboard;
  </script>
</body>
</html>
